@Title "ATOM Framework - Complete Test Suite"
@Description "Comprehensive production-level testing of all ATOM Framework features"
@Meta { name: "robots", content: "noindex, nofollow" };

// Test ISR - This page revalidates every 60 seconds
@Revalidate 60

// confetti will be available globally if canvas-confetti is installed
// For now, we'll handle it gracefully if it's not available

@Resource DB from './db';

// ============================================================================
// COMPREHENSIVE TEST SUITE FOR ATOM FRAMEWORK
// ============================================================================
// This test suite validates:
// 1. Authentication & Authorization
// 2. Database Operations (CRUD)
// 3. Server Actions (with validation & sanitization)
// 4. State Management (useState, useEffect, useRef, useMemo)
// 5. Routing & Navigation
// 6. Forms & Validation
// 7. Error Handling
// 8. Performance
// 9. Security
// 10. Real-time Features (WebSocket)
// ============================================================================

@Flow Actions {
  // ========================================================================
  // AUTHENTICATION TESTS
  // ========================================================================
  
  secure_testLogin: async function(credentials) {
    console.log('[TEST] Login attempt:', credentials);
    
    // Import validation and sanitization
    const validate = require('../system/lib/validation');
    const sanitize = require('../system/lib/sanitize');
    
    // Validate input
    const email = validate.isEmail(
      validate.required(credentials?.email, 'Email'),
      'Email'
    );
    const password = validate.required(credentials?.password, 'Password');
    
    // Sanitize
    const cleanEmail = sanitize.sanitizeEmail(email);
    
    // Mock database check (in real app, use actual DB)
    const mockUsers = [
      { id: 1, email: "test@example.com", password: "password123", name: "Test User" },
      { id: 2, email: "admin@example.com", password: "admin123", name: "Admin User" }
    ];
    
    const user = mockUsers.find(u => u.email === cleanEmail && u.password === password);
    
    if (!user) {
      throw new Error('Invalid credentials');
    }
    
    // Generate mock JWT token
    const token = `mock_jwt_${user.id}_${Date.now()}`;
    
    return {
      success: true,
      token,
      user: {
        id: user.id,
        email: user.email,
        name: user.name
      }
    };
  },
  
  secure_testRegister: async function(userData) {
    console.log('[TEST] Registration attempt:', userData);
    
    // Import validation and sanitization
    const validate = require('../system/lib/validation');
    const sanitize = require('../system/lib/sanitize');
    
    // Comprehensive validation
    const email = validate.isEmail(
      validate.required(userData?.email, 'Email'),
      'Email'
    );
    const password = validate.minLength(
      validate.required(userData?.password, 'Password'),
      8,
      'Password'
    );
    const name = validate.minLength(
      validate.required(userData?.name, 'Name'),
      2,
      'Name'
    );
    
    // Sanitize all inputs
    const cleanEmail = sanitize.sanitizeEmail(email);
    const cleanName = sanitize.sanitizeString(name, { maxLength: 100 });
    
    // Check if user exists (mock)
    const existingUsers = ["test@example.com", "admin@example.com"];
    if (existingUsers.includes(cleanEmail)) {
      throw new Error('User already exists');
    }
    
    // Create user (mock)
    const newUser = {
      id: Date.now(),
      email: cleanEmail,
      name: cleanName,
      createdAt: new Date().toISOString()
    };
    
    return {
      success: true,
      user: newUser,
      message: 'User registered successfully'
    };
  },
  
  secure_testGetCurrentUser: async function(token) {
    if (!token) {
      throw new Error('No token provided');
    }
    
    // Mock token validation
    const userId = token.split('_')[2];
    if (!userId) {
      throw new Error('Invalid token');
    }
    
    return {
      id: parseInt(userId),
      email: "test@example.com",
      name: "Test User"
    };
  },
  
  // ========================================================================
  // DATABASE OPERATION TESTS
  // ========================================================================
  
  secure_testCreateRecord: async function(data) {
    console.log('[TEST] Create record:', data);
    
    // Import validation and sanitization
    const validate = require('../system/lib/validation');
    const sanitize = require('../system/lib/sanitize');
    
    // Validate
    const title = validate.required(data?.title, 'Title');
    const content = validate.required(data?.content, 'Content');
    
    // Sanitize
    const cleanTitle = sanitize.sanitizeString(title, { maxLength: 200 });
    const cleanContent = sanitize.sanitizeHTML(content, {
      allowedTags: ['p', 'br', 'strong', 'em'],
      stripTags: false
    });
    
    // Mock database insert
    const record = {
      id: Date.now(),
      title: cleanTitle,
      content: cleanContent,
      createdAt: new Date().toISOString()
    };
    
    return {
      success: true,
      record
    };
  },
  
  secure_testGetRecords: async function(params) {
    console.log('[TEST] Get records:', params);
    
    // Import validation
    const validate = require('../system/lib/validation');
    
    // Validate pagination
    const page = params?.page ? validate.isNumber(params.page, 'Page') : 1;
    const limit = params?.limit ? validate.min(validate.isNumber(params.limit, 'Limit'), 1, 'Limit') : 10;
    
    // Mock database query
    const mockRecords = Array.from({ length: 25 }, (_, i) => ({
      id: i + 1,
      title: `Record ${i + 1}`,
      content: `Content for record ${i + 1}`,
      createdAt: new Date(Date.now() - i * 86400000).toISOString()
    }));
    
    const start = (page - 1) * limit;
    const end = start + limit;
    const paginated = mockRecords.slice(start, end);
    
    return {
      records: paginated,
      pagination: {
        page,
        limit,
        total: mockRecords.length,
        totalPages: Math.ceil(mockRecords.length / limit)
      }
    };
  },
  
  secure_testUpdateRecord: async function(data) {
    console.log('[TEST] Update record:', data);
    
    // Import validation and sanitization
    const validate = require('../system/lib/validation');
    const sanitize = require('../system/lib/sanitize');
    
    // Validate
    const id = validate.isNumber(validate.required(data?.id, 'ID'), 'ID');
    const title = data?.title ? validate.required(data.title, 'Title') : null;
    const content = data?.content ? validate.required(data.content, 'Content') : null;
    
    if (!title && !content) {
      throw new Error('At least one field (title or content) must be provided');
    }
    
    // Sanitize
    const updates = {};
    if (title) updates.title = sanitize.sanitizeString(title, { maxLength: 200 });
    if (content) updates.content = sanitize.sanitizeHTML(content);
    
    // Mock database update
    return {
      success: true,
      id,
      updates,
      updatedAt: new Date().toISOString()
    };
  },
  
  secure_testDeleteRecord: async function(id) {
    console.log('[TEST] Delete record:', id, 'Type:', typeof id);
    
    // Import validation
    const validate = require('../system/lib/validation');
    
    // Validate - isNumber now handles both numbers and numeric strings
    const recordId = validate.isNumber(validate.required(id, 'ID'), 'ID');
    
    // Mock database delete
    return {
      success: true,
      id: recordId,
      deletedAt: new Date().toISOString()
    };
  },
  
  // ========================================================================
  // VALIDATION & SANITIZATION TESTS
  // ========================================================================
  
  secure_testValidation: async function(data) {
    console.log('[TEST] Validation test:', data);
    
    // Import validation
    const validate = require('../system/lib/validation');
    
    // Test all validation types
    const schema = {
      email: (v) => validate.isEmail(validate.required(v, 'Email'), 'Email'),
      name: (v) => validate.minLength(
        validate.isString(validate.required(v, 'Name'), 'Name'),
        2,
        'Name'
      ),
      age: (v) => validate.min(
        validate.isNumber(v, 'Age'),
        18,
        'Age'
      ),
      url: (v) => validate.isURL(v, 'URL'),
      tags: (v) => validate.arrayMinLength(
        validate.isArray(v, 'Tags'),
        1,
        'Tags'
      )
    };
    
    const validated = validate.validate(data, schema);
    
    return {
      success: true,
      validated,
      message: 'All validations passed'
    };
  },
  
  secure_testSanitization: async function(data) {
    console.log('[TEST] Sanitization test:', data);
    
    // Import sanitization
    const sanitize = require('../system/lib/sanitize');
    
    // Test sanitization
    const sanitized = {
      html: sanitize.sanitizeHTML(data.html || '', {
        allowedTags: ['p', 'br', 'strong', 'em']
      }),
      string: sanitize.sanitizeString(data.string || '', {
        maxLength: 100,
        removeHTML: true
      }),
      email: sanitize.sanitizeEmail(data.email || ''),
      url: sanitize.sanitizeURL(data.url || ''),
      object: sanitize.sanitizeObject(data.object || {})
    };
    
    return {
      success: true,
      original: data,
      sanitized,
      message: 'Sanitization completed'
    };
  },
  
  // ========================================================================
  // ERROR HANDLING TESTS
  // ========================================================================
  
  secure_testErrorHandling: async function(type) {
    console.log('[TEST] Error handling test:', type);
    
    switch (type) {
      case 'validation':
        throw new Error('Validation error: Invalid input');
      case 'database':
        throw new Error('Database error: Connection failed');
      case 'permission':
        throw new Error('Permission error: Access denied');
      case 'notfound':
        throw new Error('Not found: Resource does not exist');
      default:
        throw new Error('Unknown error type');
    }
  },
  
  // ========================================================================
  // PERFORMANCE TESTS
  // ========================================================================
  
  secure_testPerformance: async function(iterations = 100) {
    console.log('[TEST] Performance test:', iterations);
    
    const start = Date.now();
    const results = [];
    
    // Simulate database operations
    for (let i = 0; i < iterations; i++) {
      results.push({
        id: i,
        data: `Item ${i}`,
        processed: true
      });
    }
    
    const duration = Date.now() - start;
    const averageTime = duration / iterations;
    
    return {
      success: true,
      iterations,
      duration,
      averageTime,
      results: results.slice(0, 10) // Return first 10
    };
  },
  
  // ========================================================================
  // FILE UPLOAD TEST (MOCK)
  // ========================================================================
  
  secure_testFileUpload: async function(fileData) {
    console.log('[TEST] File upload test:', fileData);
    
    // Import sanitization
    const sanitize = require('../system/lib/sanitize');
    
    // Validate
    if (!fileData || !fileData.name) {
      throw new Error('File data is required');
    }
    
    // Sanitize filename
    const cleanName = sanitize.sanitizeString(fileData.name, {
      maxLength: 255,
      removeHTML: true
    });
    
    // Mock file save
    return { 
      success: true,
      file: {
        id: Date.now(),
        name: cleanName,
        size: fileData.size || 0,
        type: fileData.type || 'application/octet-stream',
        uploadedAt: new Date().toISOString()
      }
    };
  },
  
  // ========================================================================
  // WEBSOCKET TEST (via server)
  // ========================================================================
  
  secure_testWebSocket: async function(message) {
    console.log('[TEST] WebSocket test:', message);
    
    // In a real implementation, this would broadcast via WebSocket
    // For now, just return success
    return {
      success: true,
      message: 'WebSocket message would be broadcast here',
      timestamp: new Date().toISOString()
    };
  },
  
  // ========================================================================
  // SECURITY TESTS
  // ========================================================================
  
  secure_testSqlInjection: async function(data) {
    console.log('[TEST] SQL injection simulation:', data);
    
    const validate = require('../system/lib/validation');
    const sanitize = require('../system/lib/sanitize');
    
    const rawInput = validate.required(data?.input, 'Input');
    const sanitizedInput = sanitize.sanitizeString(rawInput, {
      maxLength: 500,
      removeHTML: true
    });
    
    const suspiciousPatterns = /('|--|;|\/\*|\*\/|xp_)/i;
    const isSuspicious = suspiciousPatterns.test(rawInput);
    
    // Simulate parameterized query usage
    const query = 'SELECT * FROM users WHERE email = $1';
    const parameters = [sanitizedInput];
    
    return {
      success: true,
      rawInput,
      sanitizedInput,
      isSuspicious,
      query,
      parameters,
      mitigation: isSuspicious
        ? 'Suspicious input detected. Parameterized query prevents injection.'
        : 'Input looks safe. Parameterized query still used.'
    };
  }
};

@View {
  // ========================================================================
  // STATE MANAGEMENT
  // ========================================================================
  
  const [currentTest, setCurrentTest] = useState('framework');
  const [testResults, setTestResults] = useState({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [user, setUser] = useState(null);
  const [records, setRecords] = useState([]);
  
  // Ensure records is always an array
  const safeRecords = Array.isArray(records) ? records : [];
  
  // Refs for testing
  const loadingRef = useRef(false);
  const testCountRef = useRef(0);
  const lastTestRef = useRef(null);
  
  // Load confetti dynamically if available
  useEffect(() => {
    if (typeof window !== 'undefined' && !window.confetti) {
      import('canvas-confetti').then(module => {
        window.confetti = module.default || module;
      }).catch(() => {
        // confetti not available, that's okay
      });
    }
  }, []);
  
  // Helper function to safely call confetti
  const triggerConfetti = (options = {}) => {
    try {
      const confettiFn = window.confetti || (typeof confetti !== 'undefined' ? confetti : null);
      if (confettiFn && typeof confettiFn === 'function') {
        confettiFn(options);
      }
    } catch (e) {
      // confetti not available, skip
    }
  };
  
  // Memoized values
  const testCategories = useMemo(() => [
    { id: 'framework', name: 'Framework Core', icon: '‚öõÔ∏è' },
    { id: 'inputs', name: 'Input Tracking', icon: '‚å®Ô∏è' },
    { id: 'events', name: 'Event Handling', icon: 'üéØ' },
    { id: 'forms', name: 'Forms & Validation', icon: 'üìù' },
    { id: 'state', name: 'State Management', icon: 'üîÑ' },
    { id: 'html', name: 'HTML Helpers', icon: 'üè∑Ô∏è' },
    { id: 'navigation', name: 'Navigation', icon: 'üß≠' },
    { id: 'auth', name: 'Authentication', icon: 'üîê' },
    { id: 'database', name: 'Database', icon: 'üíæ' },
    { id: 'validation', name: 'Validation', icon: '‚úÖ' },
    { id: 'errors', name: 'Error Handling', icon: '‚ö†Ô∏è' },
    { id: 'performance', name: 'Performance', icon: '‚ö°' },
    { id: 'security', name: 'Security', icon: 'üõ°Ô∏è' }
  ], []);
  
  // ========================================================================
  // FRAMEWORK CORE TESTS (State Management)
  // ========================================================================
  
  const [testInputValue, setTestInputValue] = useState('');
  const [testCounter, setTestCounter] = useState(0);
  const [testEffectCount, setTestEffectCount] = useState(0);
  const [testMemoValue, setTestMemoValue] = useState(0);
  const testRef = useRef(0);
  const effectTestRef = useRef(0);
  const counterTestRef = useRef(0); // Track counter for useState test
  const memoTestRef = useRef(0); // Track memo value for useMemo test
  const [testResultsFramework, setTestResultsFramework] = useState({});
  const [testLogs, setTestLogs] = useState([]);
  
  // Helper to add log entry
  const addLog = (message, type = 'info') => {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = { timestamp, message, type };
    console.log(`[TEST ${type.toUpperCase()}] ${timestamp}: ${message}`);
    setTestLogs(prev => {
      const logs = Array.isArray(prev) ? prev : [];
      return [...logs, logEntry].slice(-50); // Keep last 50 logs
    });
  };
  
  // Test useEffect
  useEffect(() => {
    const newCount = effectTestRef.current + 1;
    effectTestRef.current = newCount;
    // Update counter ref when effect fires (confirms state updated)
    const currentCounter = typeof testCounter === 'number' ? testCounter : 0;
    counterTestRef.current = currentCounter;
    setTestEffectCount(prev => prev + 1);
    addLog(`useEffect triggered: testCounter changed to ${currentCounter} (effect count: ${newCount})`, 'success');
  }, [testCounter]);
  
  // Test useMemo
  const memoizedValue = useMemo(() => {
    const val = memoTestRef.current || (typeof testMemoValue === 'number' ? testMemoValue : 0);
    const result = val * 2;
    addLog(`useMemo recalculated: ${val} * 2 = ${result}`, 'framework');
    return result;
  }, [testMemoValue]);
  
  const testUseState = () => {
    console.log('testUseState called!');
    try {
      addLog('üß™ Starting useState test...', 'info');
      const currentValue = typeof testCounter === 'number' ? testCounter : 0;
      counterTestRef.current = currentValue;
      addLog(`üìä Current counter value: ${currentValue}`, 'info');
      
      addLog('‚öôÔ∏è Framework: Calling setTestCounter...', 'framework');
      const expectedNewValue = currentValue + 1;
      
      setTestCounter(prev => {
        const oldVal = typeof prev === 'number' ? prev : 0;
        const newVal = oldVal + 1;
        addLog(`‚öôÔ∏è Framework: State updater called (${oldVal} ‚Üí ${newVal})`, 'framework');
        counterTestRef.current = newVal; // Update ref with new value
        return newVal;
      });
      
      addLog('‚è≥ Waiting for state update and re-render...', 'info');
      // Use a ref to track the value since closures capture old values
      // The ref will be updated when the component re-renders
      let attempts = 0;
      const checkState = () => {
        attempts++;
        // Check the ref value which should be updated on re-render
        // Also check if useEffect fired (which confirms state updated)
        const refValue = counterTestRef.current;
        addLog(`üìä Check ${attempts}: Ref value = ${refValue}, Expected = ${expectedNewValue}`, 'info');
        
        // If ref was updated, state definitely updated
        if (refValue >= expectedNewValue) {
          addLog(`‚úÖ PASS: useState working correctly (${currentValue} ‚Üí ${refValue})`, 'success');
          setTestResultsFramework(prev => ({ ...prev, useState: `‚úÖ PASS: State updated successfully (${currentValue} ‚Üí ${refValue})` }));
        } else if (attempts < 10) {
          // Try again after a short delay - component might still be re-rendering
          setTimeout(checkState, 100);
        } else {
          addLog(`‚ùå FAIL: State not updated after ${attempts} attempts (expected >= ${expectedNewValue}, ref shows ${refValue})`, 'error');
          addLog('üîç Issue: Framework state update may not be working - state not updating', 'error');
          setTestResultsFramework(prev => ({ ...prev, useState: `‚ùå FAIL: State not updated (${currentValue} ‚Üí ${refValue})` }));
        }
      };
      
      setTimeout(checkState, 200);
    } catch (err) {
      addLog(`‚ùå ERROR: ${err.message}`, 'error');
      addLog('üîç Issue: Frontend test code error', 'error');
      setTestResultsFramework(prev => ({ ...prev, useState: `‚ùå FAIL: ${err.message}` }));
    }
  };
  
  const testUseEffect = () => {
    addLog('üß™ Starting useEffect test...', 'info');
    try {
      const initialEffectCount = effectTestRef.current;
      addLog(`üìä Initial effect count: ${initialEffectCount}`, 'info');
      
      addLog('‚öôÔ∏è Framework: Updating testCounter to trigger effect...', 'framework');
      setTestCounter(prev => {
        const newVal = (typeof prev === 'number' ? prev : 0) + 1;
        addLog(`‚öôÔ∏è Framework: Counter updated to ${newVal}`, 'framework');
        return newVal;
      });
      
      addLog('‚è≥ Waiting for useEffect to trigger...', 'info');
      setTimeout(() => {
        const newEffectCount = effectTestRef.current;
        addLog(`üìä New effect count: ${newEffectCount}`, 'info');
        
        if (newEffectCount > initialEffectCount) {
          addLog(`‚úÖ PASS: useEffect triggered (${initialEffectCount} ‚Üí ${newEffectCount})`, 'success');
          setTestResultsFramework(prev => ({ ...prev, useEffect: `‚úÖ PASS: Effect triggered (count: ${initialEffectCount} ‚Üí ${newEffectCount})` }));
        } else {
          addLog(`‚ùå FAIL: Effect not triggered (count: ${initialEffectCount} ‚Üí ${newEffectCount})`, 'error');
          addLog('üîç Issue: Framework useEffect may not be working or dependency not tracked', 'error');
          setTestResultsFramework(prev => ({ ...prev, useEffect: '‚ùå FAIL: Effect not triggered' }));
        }
      }, 200);
    } catch (err) {
      addLog(`‚ùå ERROR: ${err.message}`, 'error');
      addLog('üîç Issue: Frontend test code error', 'error');
      setTestResultsFramework(prev => ({ ...prev, useEffect: `‚ùå FAIL: ${err.message}` }));
    }
  };
  
  const testUseRef = () => {
    addLog('üß™ Starting useRef test...', 'info');
    try {
      const oldValue = testRef?.current || 0;
      addLog(`üìä Initial ref value: ${oldValue}`, 'info');
      
      addLog('‚öôÔ∏è Framework: Updating ref.current...', 'framework');
      testRef.current = (typeof testRef.current === 'number' ? testRef.current : 0) + 1;
      const newValue = testRef.current;
      addLog(`‚öôÔ∏è Framework: Ref updated to ${newValue}`, 'framework');
      
      if (newValue > oldValue) {
        addLog(`‚úÖ PASS: useRef working (${oldValue} ‚Üí ${newValue})`, 'success');
        setTestResultsFramework(prev => ({ ...prev, useRef: `‚úÖ PASS: Ref value updated from ${oldValue} to ${newValue}` }));
      } else {
        addLog(`‚ùå FAIL: Ref not updating (${oldValue} ‚Üí ${newValue})`, 'error');
        addLog('üîç Issue: Framework useRef may not be persisting values', 'error');
        setTestResultsFramework(prev => ({ ...prev, useRef: '‚ùå FAIL: Ref not updating' }));
      }
    } catch (err) {
      addLog(`‚ùå ERROR: ${err.message}`, 'error');
      addLog('üîç Issue: Frontend test code error', 'error');
      setTestResultsFramework(prev => ({ ...prev, useRef: `‚ùå FAIL: ${err.message}` }));
    }
  };
  
  const testUseMemo = () => {
    addLog('üß™ Starting useMemo test...', 'info');
    try {
      const oldTestValue = memoTestRef.current;
      addLog(`üìä Current testMemoValue: ${oldTestValue}`, 'info');
      
      addLog('‚öôÔ∏è Framework: Updating testMemoValue...', 'framework');
      const newVal = oldTestValue + 1;
      memoTestRef.current = newVal;
      setTestMemoValue(newVal);
      addLog(`‚öôÔ∏è Framework: testMemoValue updated to ${newVal}`, 'framework');
      
      setTimeout(() => {
        // useMemo should recalculate, but we need to check the actual memoized value
        // Since we can't directly read it, we'll check if the state updated
        const currentTestValue = memoTestRef.current;
        const expectedMemo = currentTestValue * 2;
        addLog(`üìä Expected memo: ${expectedMemo} (from testMemoValue: ${currentTestValue})`, 'info');
        
        // Trigger a re-render to get the memoized value
        setTestResultsFramework(prev => {
          // The memoized value will be calculated on next render
          // For now, just check if state updated
          if (currentTestValue > oldTestValue) {
            addLog(`‚úÖ PASS: useMemo dependency updated (${oldTestValue} ‚Üí ${currentTestValue})`, 'success');
            return { ...prev, useMemo: `‚úÖ PASS: Memo should calculate ${currentTestValue} * 2 = ${expectedMemo}` };
          } else {
            addLog(`‚ùå FAIL: State not updated`, 'error');
            return { ...prev, useMemo: `‚ùå FAIL: State not updated` };
          }
        });
      }, 200);
    } catch (err) {
      addLog(`‚ùå ERROR: ${err.message}`, 'error');
      addLog('üîç Issue: Frontend test code error', 'error');
      setTestResultsFramework(prev => ({ ...prev, useMemo: `‚ùå FAIL: ${err.message}` }));
    }
  };
  
  // Run all framework tests one by one
  const runAllFrameworkTests = async () => {
    addLog('üöÄ Starting Framework Core Test Suite...', 'info');
    setTestResultsFramework({});
    setTestLogs([]);
    
    const tests = [
      { name: 'useState', fn: testUseState },
      { name: 'useEffect', fn: testUseEffect },
      { name: 'useRef', fn: testUseRef },
      { name: 'useMemo', fn: testUseMemo }
    ];
    
    for (let i = 0; i < tests.length; i++) {
      const test = tests[i];
      addLog(`\n‚îÅ‚îÅ‚îÅ Test ${i + 1}/${tests.length}: ${test.name} ‚îÅ‚îÅ‚îÅ`, 'info');
      await new Promise(resolve => {
        test.fn();
        setTimeout(resolve, 500); // Wait for test to complete
      });
      if (i < tests.length - 1) {
        addLog('‚è∏Ô∏è  Waiting before next test...', 'info');
        await new Promise(resolve => setTimeout(resolve, 300));
      }
    }
    
    addLog('\n‚úÖ Framework Core Test Suite Complete!', 'success');
  };
  
  // ========================================================================
  // INPUT TRACKING TESTS
  // ========================================================================
  
  const [inputTest1, setInputTest1] = useState('');
  const [inputTest2, setInputTest2] = useState('');
  const [inputTest3, setInputTest3] = useState('');
  const [inputTestResults, setInputTestResults] = useState({});
  const [inputLog, setInputLog] = useState([]);
  
  // Ensure inputLog is always an array
  const safeInputLog = Array.isArray(inputLog) ? inputLog : [];
  
  const testInputTracking = () => {
    addLog('üß™ Starting Input Value Preservation test...', 'info');
    try {
      // Get current DOM values
      const input1Element = document.querySelector('input[placeholder*="Type here, then switch"]') || 
                            document.querySelectorAll('input[type="text"]')[0];
      const input2Element = document.querySelector('input[placeholder*="Switch here and type"]') || 
                            document.querySelectorAll('input[type="text"]')[1];
      
      const beforeValue1 = input1Element ? input1Element.value : '';
      const beforeValue2 = input2Element ? input2Element.value : '';
      
      addLog(`üìä Current Input 1 value: "${beforeValue1}"`, 'info');
      addLog(`üìä Current Input 2 value: "${beforeValue2}"`, 'info');
      
      const testValue1 = 'Test Value 1';
      const testValue2 = 'Test Value 2';
      
      addLog(`üìù Setting Input 1 state to: "${testValue1}"`, 'info');
      addLog('‚öôÔ∏è Framework: State update should sync to DOM if input is not focused', 'framework');
      setInputTest1(testValue1);
      
      setTimeout(() => {
        addLog(`üìù Setting Input 2 state to: "${testValue2}"`, 'info');
        setInputTest2(testValue2);
        
        setTimeout(() => {
          // Check DOM values (what user actually sees)
          const afterDomValue1 = input1Element ? input1Element.value : '';
          const afterDomValue2 = input2Element ? input2Element.value : '';
          const stateValue1 = typeof inputTest1 === 'string' ? inputTest1 : '';
          const stateValue2 = typeof inputTest2 === 'string' ? inputTest2 : '';
          
          addLog(`üìä After state update:`, 'info');
          addLog(`   Input 1 - DOM: "${afterDomValue1}", State: "${stateValue1}"`, 'info');
          addLog(`   Input 2 - DOM: "${afterDomValue2}", State: "${stateValue2}"`, 'info');
          
          // If inputs were empty, state should sync to DOM
          // If inputs had user values, framework should preserve them (correct behavior)
          const input1WasEmpty = !beforeValue1 || beforeValue1.trim() === '';
          const input2WasEmpty = !beforeValue2 || beforeValue2.trim() === '';
          
          const input1Correct = input1WasEmpty ? (afterDomValue1 === testValue1 || stateValue1 === testValue1) : 
                                              (afterDomValue1 === beforeValue1 || afterDomValue1 === testValue1);
          const input2Correct = input2WasEmpty ? (afterDomValue2 === testValue2 || stateValue2 === testValue2) : 
                                              (afterDomValue2 === beforeValue2 || afterDomValue2 === testValue2);
          
          if (input1Correct && input2Correct) {
            addLog('‚úÖ PASS: Input value preservation working correctly', 'success');
            if (!input1WasEmpty || !input2WasEmpty) {
              addLog('‚úÖ Framework correctly preserved user input over programmatic updates', 'success');
            }
            setInputTestResults(prev => ({ ...prev, valuePreservation: '‚úÖ PASS: Values preserved correctly' }));
          } else {
            addLog('‚ùå FAIL: Input values not handled correctly', 'error');
            addLog(`üîç Issue: Input 1 ${input1Correct ? 'OK' : 'MISMATCH'}, Input 2 ${input2Correct ? 'OK' : 'MISMATCH'}`, 'error');
            setInputTestResults(prev => ({ ...prev, valuePreservation: `‚ùå FAIL: Values not preserved (DOM1: ${afterDomValue1}, DOM2: ${afterDomValue2})` }));
          }
        }, 300);
      }, 300);
    } catch (err) {
      addLog(`‚ùå ERROR: ${err.message}`, 'error');
      setInputTestResults(prev => ({ ...prev, valuePreservation: `‚ùå FAIL: ${err.message}` }));
    }
  };
  
  const testInputSwitching = () => {
    addLog('üß™ Starting Input Switching test...', 'info');
    addLog('üìù This test verifies that when you type in one input, then switch to another, the first input keeps its value', 'info');
    
    // Get current DOM values before test
    const input1Element = document.querySelector('input[placeholder*="Input 1"]') || 
                          document.querySelector('input[type="text"]');
    const input2Element = document.querySelectorAll('input[type="text"]')[1];
    
    const initialValue1 = input1Element ? input1Element.value : '';
    const initialValue2 = input2Element ? input2Element.value : '';
    
    addLog(`üìä Current Input 1 value: "${initialValue1}"`, 'info');
    addLog(`üìä Current Input 2 value: "${initialValue2}"`, 'info');
    addLog('üí° Tip: Type in Input 1, then click in Input 2 and type there. Input 1 should keep its value.', 'info');
    
    try {
      const value1 = initialValue1 || 'Typing in input 1...';
      const value2 = initialValue2 || 'Now typing in input 2...';
      
      addLog(`üìù Setting Input 1 state to: "${value1}"`, 'info');
      setInputTest1(value1);
      
      setTimeout(() => {
        addLog(`üìù Setting Input 2 state to: "${value2}"`, 'info');
        addLog('‚öôÔ∏è Framework: Testing if Input 1 value is preserved when Input 2 is updated...', 'framework');
        setInputTest2(value2);
        
        setTimeout(() => {
          // Check DOM values (what actually matters)
          const finalDomValue1 = input1Element ? input1Element.value : '';
          const finalDomValue2 = input2Element ? input2Element.value : '';
          const stateValue1 = typeof inputTest1 === 'string' ? inputTest1 : '';
          const stateValue2 = typeof inputTest2 === 'string' ? inputTest2 : '';
          
          addLog(`üìä After state update:`, 'info');
          addLog(`   Input 1 - DOM: "${finalDomValue1}", State: "${stateValue1}"`, 'info');
          addLog(`   Input 2 - DOM: "${finalDomValue2}", State: "${stateValue2}"`, 'info');
          
          // If user has typed, their values should be preserved (framework working correctly)
          // If state was set, it should sync to DOM (unless user is typing)
          const valuesPreserved = (finalDomValue1 === initialValue1 || finalDomValue1 === value1) && 
                                 (finalDomValue2 === initialValue2 || finalDomValue2 === value2);
          
          if (valuesPreserved) {
            addLog('‚úÖ PASS: Input values preserved when switching/updating', 'success');
            addLog('‚úÖ Framework correctly preserves user input and syncs state', 'success');
            setInputTestResults(prev => ({ ...prev, switching: '‚úÖ PASS: Values preserved on switch' }));
          } else {
            addLog('‚ùå FAIL: Values not preserved correctly', 'error');
            addLog(`üîç Issue: Framework may be overwriting input values during state updates`, 'error');
            setInputTestResults(prev => ({ ...prev, switching: `‚ùå FAIL: Values lost (Input1: ${finalDomValue1}, Input2: ${finalDomValue2})` }));
          }
        }, 300);
      }, 300);
    } catch (err) {
      addLog(`‚ùå ERROR: ${err.message}`, 'error');
      setInputTestResults(prev => ({ ...prev, switching: `‚ùå FAIL: ${err.message}` }));
    }
  };
  
  // ========================================================================
  // EVENT HANDLING TESTS
  // ========================================================================
  
  const [eventResults, setEventResults] = useState({});
  const [clickCount, setClickCount] = useState(0);
  const [inputEventCount, setInputEventCount] = useState(0);
  const [focusCount, setFocusCount] = useState(0);
  const [blurCount, setBlurCount] = useState(0);
  const [submitCount, setSubmitCount] = useState(0);
  const [changeCount, setChangeCount] = useState(0);
  
  const testClickEvent = () => {
    setClickCount(prev => prev + 1);
    setEventResults(prev => ({ ...prev, onclick: '‚úÖ PASS' }));
  };
  
  const testInputEvent = (e) => {
    setInputEventCount(prev => prev + 1);
    if (inputEventCount >= 0) {
      setEventResults(prev => ({ ...prev, oninput: '‚úÖ PASS' }));
    }
  };
  
  const testFocusEvent = () => {
    setFocusCount(prev => prev + 1);
    setEventResults(prev => ({ ...prev, onfocus: '‚úÖ PASS' }));
  };
  
  const testBlurEvent = () => {
    setBlurCount(prev => prev + 1);
    setEventResults(prev => ({ ...prev, onblur: '‚úÖ PASS' }));
  };
  
  const testChangeEvent = (e) => {
    setChangeCount(prev => prev + 1);
    setEventResults(prev => ({ ...prev, onchange: '‚úÖ PASS' }));
  };
  
  const testSubmitEvent = (e) => {
    e.preventDefault();
    setSubmitCount(prev => prev + 1);
    setEventResults(prev => ({ ...prev, onsubmit: '‚úÖ PASS' }));
  };
  
  // ========================================================================
  // FORM TESTS
  // ========================================================================
  
  const [formData, setFormData] = useState({ name: '', email: '', message: '' });
  const [formErrors, setFormErrors] = useState({});
  const [formResults, setFormResults] = useState({});
  const [formSubmitted, setFormSubmitted] = useState(false);
  
  const testFormSubmission = (e) => {
    e.preventDefault();
    addLog('üß™ Starting Form Submission test...', 'info');
    
    // Read current form values from DOM
    const nameInput = document.querySelector('input[type="text"][placeholder*="name" i]') || 
                     document.querySelectorAll('input[type="text"]')[0];
    const emailInput = document.querySelector('input[type="email"]') || 
                      document.querySelectorAll('input[type="text"]')[1];
    const messageTextarea = document.querySelector('textarea');
    
    const data = {
      name: nameInput ? nameInput.value : (formData.name || ''),
      email: emailInput ? emailInput.value : (formData.email || ''),
      message: messageTextarea ? messageTextarea.value : (formData.message || '')
    };
    
    addLog(`üìä Submitting form with values:`, 'info');
    addLog(`   Name: "${data.name}"`, 'info');
    addLog(`   Email: "${data.email}"`, 'info');
    addLog(`   Message: "${data.message}"`, 'info');
    
    const errors = {};
    if (!data.name || data.name.trim() === '') {
      errors.name = 'Name required';
      addLog('‚ùå Validation: Name is required', 'error');
    }
    
    if (!data.email || data.email.trim() === '') {
      errors.email = 'Email required';
      addLog('‚ùå Validation: Email is required', 'error');
    } else {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(data.email)) {
        errors.email = 'Invalid email format';
        addLog(`‚ùå Validation: Email format invalid ("${data.email}")`, 'error');
      }
    }
    
    if (!data.message || data.message.trim() === '') {
      errors.message = 'Message required';
      addLog('‚ùå Validation: Message is required', 'error');
    } else if (data.message.trim().length < 10) {
      errors.message = 'Message too short (min 10 characters)';
      addLog(`‚ùå Validation: Message too short (${data.message.length} chars)`, 'error');
    }
    
    if (Object.keys(errors).length === 0) {
      addLog('‚úÖ PASS: Form validation passed, submitting...', 'success');
      setFormSubmitted(true);
      setFormResults(prev => ({ ...prev, submission: '‚úÖ PASS: Form submitted successfully' }));
    } else {
      addLog(`‚ùå FAIL: Form validation failed (${Object.keys(errors).length} error(s))`, 'error');
      setFormErrors(errors);
      setFormResults(prev => ({ ...prev, submission: `‚ùå FAIL: Validation errors (${Object.keys(errors).length} error(s))` }));
    }
  };
  
  const testFormValidation = () => {
    addLog('üß™ Starting Form Validation test...', 'info');
    try {
      // Read current form values from DOM (more reliable than state)
      const nameInput = document.querySelector('input[type="text"][placeholder*="name" i]') || 
                       document.querySelectorAll('input[type="text"]')[0];
      const emailInput = document.querySelector('input[type="email"]') || 
                        document.querySelectorAll('input[type="text"]')[1];
      const messageTextarea = document.querySelector('textarea');
      
      const nameValue = nameInput ? nameInput.value : (formData.name || '');
      const emailValue = emailInput ? emailInput.value : (formData.email || '');
      const messageValue = messageTextarea ? messageTextarea.value : (formData.message || '');
      
      addLog(`üìä Form values:`, 'info');
      addLog(`   Name: "${nameValue}"`, 'info');
      addLog(`   Email: "${emailValue}"`, 'info');
      addLog(`   Message: "${messageValue}"`, 'info');
      
      const errors = {};
      if (!nameValue || nameValue.trim() === '') {
        errors.name = 'Name required';
        addLog('‚ùå Validation: Name is required', 'error');
      } else {
        addLog('‚úÖ Validation: Name is valid', 'success');
      }
      
      if (!emailValue || emailValue.trim() === '') {
        errors.email = 'Email required';
        addLog('‚ùå Validation: Email is required', 'error');
      } else {
        // Check email format
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(emailValue)) {
          errors.email = 'Invalid email format';
          addLog(`‚ùå Validation: Email format invalid ("${emailValue}")`, 'error');
        } else {
          addLog('‚úÖ Validation: Email format is valid', 'success');
        }
      }
      
      if (!messageValue || messageValue.trim() === '') {
        errors.message = 'Message required';
        addLog('‚ùå Validation: Message is required', 'error');
      } else if (messageValue.trim().length < 10) {
        errors.message = 'Message too short (min 10 characters)';
        addLog(`‚ùå Validation: Message too short (${messageValue.length} chars)`, 'error');
      } else {
        addLog('‚úÖ Validation: Message is valid', 'success');
      }
      
      addLog(`üìä Total validation errors: ${Object.keys(errors).length}`, 'info');
      setFormErrors(errors);
      
      if (Object.keys(errors).length > 0) {
        addLog(`‚úÖ PASS: Validation detected ${Object.keys(errors).length} error(s)`, 'success');
        setFormResults(prev => ({ ...prev, validation: `‚úÖ PASS: Validation working (${Object.keys(errors).length} error(s) detected)` }));
      } else {
        addLog('‚ùå FAIL: No validation errors detected (form should have errors)', 'error');
        addLog('üîç Issue: Validation may not be checking email format or message length', 'error');
        setFormResults(prev => ({ ...prev, validation: '‚ùå FAIL: No errors detected (validation may be incomplete)' }));
      }
    } catch (err) {
      addLog(`‚ùå ERROR: ${err.message}`, 'error');
      setFormResults(prev => ({ ...prev, validation: `‚ùå FAIL: ${err.message}` }));
    }
  };
  
  // ========================================================================
  // STATE MANAGEMENT TESTS
  // ========================================================================
  
  const [stateTestCounter, setStateTestCounter] = useState(0);
  const [stateTestObject, setStateTestObject] = useState({ count: 0, name: 'Test' });
  const [stateTestArray, setStateTestArray] = useState([1, 2, 3]);
  const [stateTestResults, setStateTestResults] = useState({});
  const [stateTestLogs, setStateTestLogs] = useState([]);
  
  // Refs to track expected values for async checks
  const stateCounterRef = useRef(0);
  const stateObjectCountRef = useRef(0);
  const stateArrayLengthRef = useRef(3);
  
  const addStateLog = (message, type = 'info') => {
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = { timestamp, message, type };
    console.log(`[STATE TEST ${type.toUpperCase()}] ${timestamp}: ${message}`);
    setStateTestLogs(prev => {
      const logs = Array.isArray(prev) ? prev : [];
      return [...logs, logEntry].slice(-30);
    });
  };
  
  // Effect to sync refs with state
  useEffect(() => {
    stateCounterRef.current = typeof stateTestCounter === 'number' ? stateTestCounter : 0;
  }, [stateTestCounter]);
  
  useEffect(() => {
    stateObjectCountRef.current = stateTestObject?.count || 0;
  }, [stateTestObject]);
  
  useEffect(() => {
    stateArrayLengthRef.current = Array.isArray(stateTestArray) ? stateTestArray.length : 0;
  }, [stateTestArray]);
  
  const testStateUpdate = () => {
    addStateLog('üß™ Testing basic state update...', 'info');
    const oldValue = typeof stateTestCounter === 'number' ? stateTestCounter : 0;
    addStateLog(`üìä Current value: ${oldValue}`, 'info');
    
    const expectedNewValue = oldValue + 1;
    stateCounterRef.current = expectedNewValue; // Track expected value
    
    setStateTestCounter(prev => {
      const newVal = (typeof prev === 'number' ? prev : 0) + 1;
      addStateLog(`‚öôÔ∏è Framework: State updater called (${prev} ‚Üí ${newVal})`, 'framework');
      return newVal;
    });
    
    // Check multiple times to account for async updates
    // Use ref value which is updated by useEffect on state change
    let attempts = 0;
    const maxAttempts = 15;
    const checkState = () => {
      attempts++;
      // Read from ref which is synced by useEffect (avoids closure issue)
      const refValue = stateCounterRef.current;
      // Also try reading from global state as fallback
      const globalState = typeof window !== 'undefined' && window.__ATOM_STATE__ ? window.__ATOM_STATE__ : [];
      const globalValue = Array.isArray(globalState) && globalState.length > 0 ? globalState[0] : undefined;
      const currentValue = typeof refValue === 'number' ? refValue : (typeof globalValue === 'number' ? globalValue : 0);
      
      addStateLog(`üìä Check ${attempts}: Ref value = ${refValue}, Global state[0] = ${globalValue}, Expected = ${expectedNewValue}`, 'info');
      
      if (currentValue >= expectedNewValue) {
        addStateLog(`‚úÖ PASS: State updated (${oldValue} ‚Üí ${currentValue})`, 'success');
        setStateTestResults(prev => ({ ...prev, basicUpdate: '‚úÖ PASS' }));
      } else if (attempts < maxAttempts) {
        setTimeout(checkState, 100);
      } else {
        addStateLog(`‚ùå FAIL: State not updated after ${maxAttempts} attempts (expected ${expectedNewValue}, ref shows ${refValue}, global shows ${globalValue})`, 'error');
        addStateLog('üîç Issue: Framework state update may not be working correctly', 'error');
        setStateTestResults(prev => ({ ...prev, basicUpdate: '‚ùå FAIL' }));
      }
    };
    
    setTimeout(checkState, 200);
  };
  
  const testStateObject = () => {
    addStateLog('üß™ Testing state with objects...', 'info');
    const oldCount = stateTestObject?.count || 0;
    const expectedNewCount = oldCount + 1;
    
    setStateTestObject(prev => {
      const newObj = { ...prev, count: (prev?.count || 0) + 1 };
      addStateLog(`‚öôÔ∏è Framework: Object state updated (count: ${prev?.count || 0} ‚Üí ${newObj.count})`, 'framework');
      return newObj;
    });
    
    let attempts = 0;
    const maxAttempts = 10;
    const checkState = () => {
      attempts++;
      const refCount = typeof stateObjectCountRef.current === 'number'
        ? stateObjectCountRef.current
        : NaN;
      const fallbackCount = stateTestObject?.count || 0;
      const currentCount = Number.isFinite(refCount) ? refCount : fallbackCount;
      addStateLog(`üìä Check ${attempts}: Object count = ${currentCount} (ref: ${refCount}, state: ${fallbackCount}), Expected = ${expectedNewCount}`, 'info');
      
      if (currentCount >= expectedNewCount) {
        addStateLog(`‚úÖ PASS: Object state updated (${oldCount} ‚Üí ${currentCount})`, 'success');
        setStateTestResults(prev => ({ ...prev, objectState: '‚úÖ PASS' }));
      } else if (attempts < maxAttempts) {
        setTimeout(checkState, 50);
      } else {
        addStateLog(`‚ùå FAIL: Object state not updated after ${maxAttempts} attempts`, 'error');
        setStateTestResults(prev => ({ ...prev, objectState: '‚ùå FAIL' }));
      }
    };
    
    setTimeout(checkState, 100);
  };
  
  const testStateArray = () => {
    addStateLog('üß™ Testing state with arrays...', 'info');
    const oldLength = Array.isArray(stateTestArray) ? stateTestArray.length : 0;
    const expectedNewLength = oldLength + 1;
    
    setStateTestArray(prev => {
      const newArr = Array.isArray(prev) ? [...prev, prev.length + 1] : [1];
      addStateLog(`‚öôÔ∏è Framework: Array state updated (length: ${prev?.length || 0} ‚Üí ${newArr.length})`, 'framework');
      return newArr;
    });
    
    let attempts = 0;
    const maxAttempts = 10;
    const checkState = () => {
      attempts++;
      const refLength = typeof stateArrayLengthRef.current === 'number'
        ? stateArrayLengthRef.current
        : NaN;
      const fallbackLength = Array.isArray(stateTestArray) ? stateTestArray.length : 0;
      const currentLength = Number.isFinite(refLength) ? refLength : fallbackLength;
      addStateLog(`üìä Check ${attempts}: Array length = ${currentLength} (ref: ${refLength}, state: ${fallbackLength}), Expected = ${expectedNewLength}`, 'info');
      
      if (currentLength >= expectedNewLength) {
        addStateLog(`‚úÖ PASS: Array state updated (length: ${oldLength} ‚Üí ${currentLength})`, 'success');
        setStateTestResults(prev => ({ ...prev, arrayState: '‚úÖ PASS' }));
      } else if (attempts < maxAttempts) {
        setTimeout(checkState, 50);
      } else {
        addStateLog(`‚ùå FAIL: Array state not updated after ${maxAttempts} attempts`, 'error');
        setStateTestResults(prev => ({ ...prev, arrayState: '‚ùå FAIL' }));
      }
    };
    
    setTimeout(checkState, 100);
  };
  
  const testStateBatching = () => {
    addStateLog('üß™ Testing state update batching...', 'info');
    const initialValue = typeof stateTestCounter === 'number' ? stateTestCounter : 0;
    const expectedFinalValue = initialValue + 3;
    
    // Multiple rapid updates
    setStateTestCounter(prev => (typeof prev === 'number' ? prev : 0) + 1);
    setStateTestCounter(prev => (typeof prev === 'number' ? prev : 0) + 1);
    setStateTestCounter(prev => (typeof prev === 'number' ? prev : 0) + 1);
    addStateLog('‚öôÔ∏è Framework: Sent 3 rapid state updates', 'framework');
    
    let attempts = 0;
    const maxAttempts = 15;
    const checkState = () => {
      attempts++;
      const refValue = typeof stateCounterRef.current === 'number' ? stateCounterRef.current : NaN;
      const fallbackValue = typeof stateTestCounter === 'number' ? stateTestCounter : 0;
      const finalValue = Number.isFinite(refValue) ? refValue : fallbackValue;
      addStateLog(`üìä Check ${attempts}: Final value = ${finalValue} (ref: ${refValue}, state: ${fallbackValue}), Expected >= ${expectedFinalValue}`, 'info');
      
      if (finalValue >= expectedFinalValue) {
        addStateLog(`‚úÖ PASS: State batching working (${initialValue} ‚Üí ${finalValue})`, 'success');
        setStateTestResults(prev => ({ ...prev, batching: '‚úÖ PASS' }));
      } else if (attempts < maxAttempts) {
        setTimeout(checkState, 50);
      } else {
        addStateLog(`‚ùå FAIL: State batching issue after ${maxAttempts} attempts (expected >= ${expectedFinalValue}, got ${finalValue})`, 'error');
        setStateTestResults(prev => ({ ...prev, batching: '‚ùå FAIL' }));
      }
    };
    
    setTimeout(checkState, 150);
  };
  
  const [persistTestState, setPersistTestState] = useState('Initial');
  const persistTestRef = useRef('Initial');
  
  useEffect(() => {
    persistTestRef.current = typeof persistTestState === 'string' ? persistTestState : 'Initial';
  }, [persistTestState]);
  
  const testStatePersistence = () => {
    addStateLog('üß™ Testing state persistence across re-renders...', 'info');
    const testValue = 'Persistent Value ' + Date.now();
    addStateLog(`üìù Setting state to: "${testValue}"`, 'info');
    
    setPersistTestState(testValue);
    
    let attempts = 0;
    const maxAttempts = 10;
    const checkState = () => {
      attempts++;
      const refValue = typeof persistTestRef.current === 'string' ? persistTestRef.current : '';
      const fallbackValue = typeof persistTestState === 'string' ? persistTestState : '';
      const currentValue = refValue || fallbackValue;
      addStateLog(`üìä Check ${attempts}: Current state value: "${currentValue}" (ref: "${refValue}", state: "${fallbackValue}")`, 'info');
      
      if (currentValue && (currentValue === testValue || currentValue.includes('Persistent Value'))) {
        addStateLog(`‚úÖ PASS: State persisted correctly (${currentValue})`, 'success');
        setStateTestResults(prev => ({ ...prev, persistence: '‚úÖ PASS: State persists across re-renders' }));
      } else if (attempts < maxAttempts) {
        setTimeout(checkState, 50);
      } else {
        addStateLog(`‚ùå FAIL: State not persisted after ${maxAttempts} attempts (expected "${testValue}", got "${currentValue}")`, 'error');
        setStateTestResults(prev => ({ ...prev, persistence: '‚ùå FAIL: State not persisting' }));
      }
    };
    
    setTimeout(checkState, 100);
  };
  
  // ========================================================================
  // HTML HELPERS TESTS
  // ========================================================================
  
  const [htmlResults, setHtmlResults] = useState({});
  
  const testHtmlHelpers = () => {
    try {
      setHtmlResults(prev => ({ ...prev, helpers: '‚úÖ PASS: All helpers available' }));
    } catch (err) {
      setHtmlResults(prev => ({ ...prev, helpers: `‚ùå FAIL: ${err.message}` }));
    }
  };
  
  // ========================================================================
  // NAVIGATION TESTS
  // ========================================================================
  
  const [navResults, setNavResults] = useState({});
  
  const testNavigation = () => {
    try {
      const currentPath = usePath();
      if (currentPath) {
        setNavResults(prev => ({ ...prev, usePath: '‚úÖ PASS' }));
      } else {
        setNavResults(prev => ({ ...prev, usePath: '‚ùå FAIL: usePath not working' }));
      }
    } catch (err) {
      setNavResults(prev => ({ ...prev, usePath: `‚ùå FAIL: ${err.message}` }));
    }
  };
  
  const testNavigate = () => {
    try {
      navigate('/test');
      setTimeout(() => {
        if (window.location.pathname === '/test') {
          setNavResults(prev => ({ ...prev, navigate: '‚úÖ PASS' }));
          navigate('/test-suite');
        } else {
          setNavResults(prev => ({ ...prev, navigate: '‚ùå FAIL: Navigation not working' }));
        }
      }, 100);
    } catch (err) {
      setNavResults(prev => ({ ...prev, navigate: `‚ùå FAIL: ${err.message}` }));
    }
  };
  
  // ========================================================================
  // AUTHENTICATION TESTS
  // ========================================================================
  
  const testLogin = async () => {
    if (loadingRef.current) return;
    loadingRef.current = true;
    setLoading(true);
    setError(null);
    
    try {
      const result = await Actions.secure_testLogin({
        email: "test@example.com",
        password: 'password123'
      });
      
      if (result && result.success) {
        if (result.token) localStorage.setItem('test_token', result.token);
        if (result.user) setUser(result.user);
        setTestResults(prev => ({ ...prev, login: '‚úÖ PASS' }));
        triggerConfetti({ particleCount: 50, spread: 70 });
      } else {
        setTestResults(prev => ({ ...prev, login: '‚ùå FAIL: Unexpected response format' }));
      }
    } catch (err) {
      setError(err.message);
      setTestResults(prev => ({ ...prev, login: `‚ùå FAIL: ${err.message}` }));
    } finally {
      setLoading(false);
      loadingRef.current = false;
    }
  };
  
  const testRegister = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await Actions.secure_testRegister({
        email: `test${Date.now()}@example.com`,
        password: 'password123',
        name: 'Test User'
      });
      
      if (result && result.success) {
        setTestResults(prev => ({ ...prev, register: '‚úÖ PASS' }));
        alert('Registration successful!');
      } else {
        setTestResults(prev => ({ ...prev, register: '‚ùå FAIL: Unexpected response format' }));
      }
    } catch (err) {
      setError(err.message);
      setTestResults(prev => ({ ...prev, register: `‚ùå FAIL: ${err.message}` }));
    } finally {
      setLoading(false);
    }
  };
  
  const testGetCurrentUser = async () => {
    const token = localStorage.getItem('test_token');
    if (!token) {
      setError('No token found. Please login first.');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const result = await Actions.secure_testGetCurrentUser(token);
      if (result) {
        setUser(result);
        setTestResults(prev => ({ ...prev, getCurrentUser: '‚úÖ PASS' }));
      } else {
        setTestResults(prev => ({ ...prev, getCurrentUser: '‚ùå FAIL: No user data returned' }));
      }
    } catch (err) {
      setError(err.message);
      setTestResults(prev => ({ ...prev, getCurrentUser: `‚ùå FAIL: ${err.message}` }));
    } finally {
      setLoading(false);
    }
  };
  
  // ========================================================================
  // DATABASE TESTS
  // ========================================================================
  
  const testCreateRecord = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await Actions.secure_testCreateRecord({
        title: 'Test Record',
        content: '<p>This is a <strong>test</strong> record</p>'
      });
      
      if (result && result.record) {
        setRecords(prev => {
          const prevArr = Array.isArray(prev) ? prev : [];
          const newRecord = result.record;
          return newRecord ? [newRecord, ...prevArr] : prevArr;
        });
        setTestResults(prev => ({ ...prev, createRecord: '‚úÖ PASS' }));
      } else {
        setTestResults(prev => ({ ...prev, createRecord: '‚ùå FAIL: No record returned' }));
      }
    } catch (err) {
      setError(err.message);
      setTestResults(prev => ({ ...prev, createRecord: `‚ùå FAIL: ${err.message}` }));
    } finally {
      setLoading(false);
    }
  };
  
  const testGetRecords = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await Actions.secure_testGetRecords({ page: 1, limit: 10 });
      if (result && Array.isArray(result.records)) {
        setRecords(result.records);
        setTestResults(prev => ({ ...prev, getRecords: '‚úÖ PASS' }));
      } else {
        setRecords([]);
        setTestResults(prev => ({ ...prev, getRecords: '‚ùå FAIL: Invalid response format' }));
      }
    } catch (err) {
      setError(err.message);
      setTestResults(prev => ({ ...prev, getRecords: `‚ùå FAIL: ${err.message}` }));
    } finally {
      setLoading(false);
    }
  };
  
  const testUpdateRecord = async () => {
    const arr = Array.isArray(records) ? records : [];
    if (arr.length === 0) {
      setError('No records to update. Create a record first.');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const firstRecord = arr[0];
      if (!firstRecord || !firstRecord.id) {
        setError('Invalid record to update.');
        return;
      }
      const result = await Actions.secure_testUpdateRecord({
        id: firstRecord.id,
        title: 'Updated Record',
        content: 'Updated content'
      });
      
      if (result && result.success) {
        setTestResults(prev => ({ ...prev, updateRecord: '‚úÖ PASS' }));
      } else {
        setTestResults(prev => ({ ...prev, updateRecord: '‚ùå FAIL: Update failed' }));
      }
    } catch (err) {
      setError(err.message);
      setTestResults(prev => ({ ...prev, updateRecord: `‚ùå FAIL: ${err.message}` }));
    } finally {
      setLoading(false);
    }
  };
  
  const testDeleteRecord = async () => {
    const arr = Array.isArray(records) ? records : [];
    if (arr.length === 0) {
      setError('No records to delete. Create a record first.');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      const firstRecord = arr[0];
      if (!firstRecord || !firstRecord.id) {
        setError('Invalid record to delete.');
        return;
      }
      // Ensure ID is passed as a number (not string)
      const recordId = typeof firstRecord.id === 'number' ? firstRecord.id : Number(firstRecord.id);
      if (isNaN(recordId)) {
        setError('Invalid record ID.');
        return;
      }
      const result = await Actions.secure_testDeleteRecord(recordId);
      if (result && result.success) {
        setRecords(prev => {
          const prevArr = Array.isArray(prev) ? prev : [];
          return prevArr.filter(r => r && r.id !== firstRecord.id);
        });
        setTestResults(prev => ({ ...prev, deleteRecord: '‚úÖ PASS' }));
      } else {
        setTestResults(prev => ({ ...prev, deleteRecord: '‚ùå FAIL: Delete failed' }));
      }
    } catch (err) {
      setError(err.message);
      setTestResults(prev => ({ ...prev, deleteRecord: `‚ùå FAIL: ${err.message}` }));
    } finally {
      setLoading(false);
    }
  };

  // ========================================================================
  // VALIDATION & SANITIZATION TESTS
  // ========================================================================
  
  const testValidation = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await Actions.secure_testValidation({
        email: "test@example.com",
        name: 'Test User',
        age: 25,
        url: 'https://example.com',
        tags: ['tag1', 'tag2']
      });
      
      if (result && result.success) {
        setTestResults(prev => ({ ...prev, validation: '‚úÖ PASS' }));
      } else {
        setTestResults(prev => ({ ...prev, validation: '‚ùå FAIL: Validation failed' }));
      }
    } catch (err) {
      setError(err.message);
      setTestResults(prev => ({ ...prev, validation: `‚ùå FAIL: ${err.message}` }));
    } finally {
      setLoading(false);
    }
  };

  const testSanitization = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await Actions.secure_testSanitization({
        html: '<p>Test <script>alert("xss")</script></p>',
        string: '<strong>Test</strong> String',
        email: "test@example.com",
        url: 'javascript:alert("xss")',
        object: { name: '<script>alert("xss")</script>' }
      });
      
      if (result && result.success) {
        setTestResults(prev => ({ ...prev, sanitization: '‚úÖ PASS' }));
      } else {
        setTestResults(prev => ({ ...prev, sanitization: '‚ùå FAIL: Sanitization failed' }));
      }
    } catch (err) {
      setError(err.message);
      setTestResults(prev => ({ ...prev, sanitization: `‚ùå FAIL: ${err.message}` }));
    } finally {
      setLoading(false);
    }
  };
  
  const testSqlInjectionPrevention = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const payload = await Actions.secure_testSqlInjection({
        input: `' OR 1=1; DROP TABLE users; --`
      });
      
      if (payload && payload.success) {
        const statusMessage = payload.isSuspicious
          ? 'Suspicious input detected and neutralized via parameterized query'
          : 'Input sanitized and executed via parameterized query';
        const details = `Query: ${payload.query} | Parameters: ${JSON.stringify(payload.parameters)}`;
        setTestResults(prev => ({
          ...prev,
          sqlInjection: `‚úÖ PASS: ${statusMessage}. ${details}`
        }));
      } else {
        setTestResults(prev => ({
          ...prev,
          sqlInjection: '‚ùå FAIL: Unexpected SQL injection response'
        }));
      }
    } catch (err) {
      setError(err.message);
      setTestResults(prev => ({
        ...prev,
        sqlInjection: `‚ùå FAIL: ${err.message}`
      }));
    } finally {
      setLoading(false);
    }
  };
  
  // ========================================================================
  // ERROR HANDLING TESTS
  // ========================================================================
  
  const testErrorHandling = async (type) => {
    setLoading(true);
    setError(null);
    
    try {
      await Actions.secure_testErrorHandling(type);
      setTestResults(prev => ({ ...prev, [`error_${type}`]: '‚ùå FAIL: Should have thrown error' }));
    } catch (err) {
      setTestResults(prev => ({ ...prev, [`error_${type}`]: `‚úÖ PASS: ${err.message}` }));
    } finally {
    setLoading(false);
    }
  };

  // ========================================================================
  // PERFORMANCE TESTS
  // ========================================================================
  
  const testPerformance = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await Actions.secure_testPerformance(1000);
      const iterationsNum = Number(result?.iterations);
      const durationNum = Number(result?.duration);
      const hasIterations = Number.isFinite(iterationsNum);
      const hasDuration = Number.isFinite(durationNum);
      if (result && hasIterations && hasDuration) {
        const avgBase = Number.isFinite(result?.averageTime)
          ? result.averageTime
          : (iterationsNum !== 0 ? durationNum / iterationsNum : 0);
        const avgTime = Number.isFinite(avgBase) ? avgBase.toFixed(2) : '0.00';
        setTestResults(prev => ({
          ...prev,
          performance: `‚úÖ PASS: ${iterationsNum} iterations in ${durationNum}ms (avg: ${avgTime}ms)`
        }));
      } else {
        console.warn('[STATE TEST ERROR] Invalid performance payload:', result);
        setTestResults(prev => ({
          ...prev,
          performance: '‚ùå FAIL: Invalid performance result'
        }));
      }
    } catch (err) {
      setError(err.message);
      setTestResults(prev => ({ ...prev, performance: `‚ùå FAIL: ${err.message}` }));
    } finally {
      setLoading(false);
    }
  };
  
  // ========================================================================
  // RUN ALL TESTS
  // ========================================================================
  
  const runAllTests = async () => {
    setLoading(true);
    setError(null);
    setTestResults({});
    testCountRef.current = 0;
    
    const tests = [
      { name: 'login', fn: testLogin },
      { name: 'register', fn: testRegister },
      { name: 'getCurrentUser', fn: testGetCurrentUser },
      { name: 'createRecord', fn: testCreateRecord },
      { name: 'getRecords', fn: testGetRecords },
      { name: 'updateRecord', fn: testUpdateRecord },
      { name: 'deleteRecord', fn: testDeleteRecord },
      { name: 'validation', fn: testValidation },
      { name: 'sanitization', fn: testSanitization },
      { name: 'performance', fn: testPerformance }
    ];
    
    for (const test of tests) {
      lastTestRef.current = test.name;
      try {
        await test.fn();
        testCountRef.current++;
        await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
      } catch (err) {
        console.error(`Test ${test.name} failed:`, err);
      }
    }
    
    setLoading(false);
    triggerConfetti({ particleCount: 100, spread: 70 });
    alert(`Tests completed! ${testCountRef.current}/${tests.length} passed.`);
  };
  
  // ========================================================================
  // RENDER
  // ========================================================================

  return div([
    // Header
    div([
      h1("üß™ ATOM Framework - Complete Test Suite", {
        className: "text-4xl font-bold mb-2"
      }),
      p("Comprehensive production-level testing of all framework features", {
        className: "text-gray-600 mb-6"
      }),
      user && div([
        span(`Logged in as: ${user.name} (${user.email})`, {
          className: "text-green-600 font-semibold"
        }),
        button("Logout", {
          onclick: () => {
            localStorage.removeItem('test_token');
            setUser(null);
            setRecords([]);
          },
          className: "ml-4 px-3 py-1 bg-red-500 text-white rounded text-sm"
        })
      ], { className: "mb-4" })
    ], { className: "mb-8" }),
    
    // Error Display
    error && div([
      p(`Error: ${error}`, {
        className: "text-red-600 bg-red-50 p-4 rounded mb-4"
      })
    ]),
    
    // Test Categories
    div([
      h2("Test Categories", { className: "text-2xl font-bold mb-4" }),
      div(
        testCategories.map(cat =>
          button([
            span(cat.icon, { className: "mr-2" }),
            span(cat.name)
          ], {
            onclick: () => setCurrentTest(cat.id),
            className: `px-4 py-2 rounded mr-2 mb-2 ${
              currentTest === cat.id 
                ? 'bg-blue-600 text-white' 
                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`
          })
        ),
        { className: "flex flex-wrap mb-6" }
      ),
      button("üöÄ Run All Tests", {
        onclick: runAllTests,
        disabled: loading,
        className: "px-6 py-3 bg-green-600 text-white rounded font-bold hover:bg-green-700 disabled:opacity-50 mb-6"
      })
    ], { className: "mb-8" }),
    
    // Framework Core Tests
    currentTest === 'framework' && div([
      h2("‚öõÔ∏è Framework Core Tests", { className: "text-2xl font-bold mb-4" }),
      div([
        button("Test useState", {
          onclick: (e) => {
            console.log('Button clicked!', e);
            e.preventDefault();
            e.stopPropagation();
            testUseState();
          },
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        button("Test useEffect", {
          onclick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            testUseEffect();
          },
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        button("Test useRef", {
          onclick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            testUseRef();
          },
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        button("Test useMemo", {
          onclick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            testUseMemo();
          },
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        button("üöÄ Run All Framework Tests", {
          onclick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            runAllFrameworkTests();
          },
          className: "px-4 py-2 bg-green-600 text-white rounded mr-2 mb-2 font-bold"
        }),
        button("Clear Logs", {
          onclick: () => setTestLogs([]),
          className: "px-4 py-2 bg-gray-600 text-white rounded mr-2 mb-2"
        })
      ], { className: "mb-4" }),
      div([
        p(`Counter: ${typeof testCounter === 'number' ? testCounter : 0}`, { className: "text-sm text-gray-600" }),
        p(`Effect Count: ${typeof testEffectCount === 'number' ? testEffectCount : 0}`, { className: "text-sm text-gray-600" }),
        p(`Ref Value: ${typeof testRef?.current === 'number' ? testRef.current : (testRef?.current || 0)}`, { className: "text-sm text-gray-600" }),
        p(`Memo Value: ${typeof memoizedValue === 'number' && !isNaN(memoizedValue) ? memoizedValue : 0}`, { className: "text-sm text-gray-600" })
      ], { className: "mb-4 p-4 bg-gray-50 rounded" }),
      div([
        h3("Results:", { className: "font-bold mb-2" }),
        ...(() => {
          const results = testResultsFramework || {};
          const entries = Object.entries(results);
          if (entries.length > 0) {
            return entries.map(([key, value]) =>
              div(`${key}: ${value}`, {
                className: "p-2 bg-gray-100 rounded mb-1"
              })
            );
          } else {
            return [div("No test results yet. Click a test button above.", {
              className: "p-2 bg-gray-50 rounded text-gray-500 italic"
            })];
          }
        })()
      ], { className: "mb-4" }),
      
      // Test Logs
      div([
        h3("üìã Test Logs:", { className: "font-bold mb-2" }),
        div([
          ...(() => {
            const logs = Array.isArray(testLogs) ? testLogs : [];
            if (logs.length === 0) {
              return [div("No logs yet. Run a test to see detailed execution logs.", {
                className: "p-2 bg-gray-50 rounded text-gray-500 italic"
              })];
            }
            return logs.slice(-30).map((log, idx) => {
              const bgColor = log.type === 'error' ? 'bg-red-50 border-red-200' : 
                            log.type === 'success' ? 'bg-green-50 border-green-200' :
                            log.type === 'framework' ? 'bg-blue-50 border-blue-200' :
                            'bg-gray-50 border-gray-200';
              const textColor = log.type === 'error' ? 'text-red-800' : 
                              log.type === 'success' ? 'text-green-800' :
                              log.type === 'framework' ? 'text-blue-800' :
                              'text-gray-800';
              return div([
                span(`[${log.timestamp}]`, { className: "text-xs text-gray-500 mr-2" }),
                span(log.message, { className: textColor })
              ], {
                className: `p-2 border rounded mb-1 text-sm ${bgColor}`
              });
            });
          })()
        ], { className: "max-h-96 overflow-y-auto" })
      ])
    ], { className: "mb-8 p-4 border rounded" }),
    
    // Input Tracking Tests
    currentTest === 'inputs' && div([
      h2("‚å®Ô∏è Input Tracking Tests", { className: "text-2xl font-bold mb-4" }),
      p("Type in the inputs below and switch between them to test value preservation:", {
        className: "text-gray-600 mb-4"
      }),
      div([
        div([
          label("Input 1:", { className: "block mb-1 font-medium" }),
          input(null, {
            type: "text",
            value: inputTest1,
            placeholder: "Type here, then switch to Input 2",
            className: "w-full px-3 py-2 border rounded",
            oninput: (e) => {
              setInputTest1(e.target.value);
              setInputLog(prev => [...prev, `Input 1: ${e.target.value}`]);
            },
            onfocus: testFocusEvent,
            onblur: testBlurEvent
          })
        ], { className: "mb-4" }),
        div([
          label("Input 2:", { className: "block mb-1 font-medium" }),
          input(null, {
            type: "text",
            value: inputTest2,
            placeholder: "Switch here and type - Input 1 should keep its value",
            className: "w-full px-3 py-2 border rounded",
            oninput: (e) => {
              setInputTest2(e.target.value);
              setInputLog(prev => [...prev, `Input 2: ${e.target.value}`]);
            },
            onfocus: testFocusEvent,
            onblur: testBlurEvent
          })
        ], { className: "mb-4" }),
        div([
          label("Textarea:", { className: "block mb-1 font-medium" }),
          textarea(null, {
            value: inputTest3,
            placeholder: "Test textarea value preservation",
            className: "w-full px-3 py-2 border rounded h-24",
            oninput: (e) => {
              setInputTest3(e.target.value);
              setInputLog(prev => [...prev, `Textarea: ${e.target.value}`]);
            }
          })
        ], { className: "mb-4" })
      ], { className: "mb-4" }),
      div([
        button("Test Value Preservation", {
          onclick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            testInputTracking();
          },
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        button("Test Input Switching", {
          onclick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            testInputSwitching();
          },
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        })
      ], { className: "mb-4" }),
      safeInputLog.length > 0 && div([
        h3("Input Log:", { className: "font-bold mb-2" }),
        ...safeInputLog.slice(-10).map(log =>
          div(log, { className: "text-sm text-gray-600 p-1" })
        )
      ], { className: "mb-4 p-4 bg-gray-50 rounded max-h-40 overflow-y-auto" }),
      div([
        h3("Results:", { className: "font-bold mb-2" }),
        ...Object.entries(inputTestResults || {}).map(([key, value]) =>
          div(`${key}: ${value}`, {
            className: "p-2 bg-gray-100 rounded mb-1"
          })
        )
      ])
    ], { className: "mb-8 p-4 border rounded" }),
    
    // Event Handling Tests
    currentTest === 'events' && div([
      h2("üéØ Event Handling Tests", { className: "text-2xl font-bold mb-4" }),
      div([
        button("Test Click Event", {
          onclick: testClickEvent,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        span(`Clicks: ${clickCount}`, { className: "text-sm text-gray-600 ml-2" })
      ], { className: "mb-4" }),
      div([
        label("Test Input Event:", { className: "block mb-1 font-medium" }),
        input(null, {
          type: "text",
          placeholder: "Type here to test oninput",
          className: "w-full px-3 py-2 border rounded mb-2",
          oninput: testInputEvent,
          onfocus: testFocusEvent,
          onblur: testBlurEvent,
          onchange: testChangeEvent
        }),
        span(`Input Events: ${inputEventCount}`, { className: "text-sm text-gray-600" })
      ], { className: "mb-4" }),
      div([
        label("Test Select Change:", { className: "block mb-1 font-medium" }),
        select([
          option("Option 1", { value: "1" }),
          option("Option 2", { value: "2" }),
          option("Option 3", { value: "3" })
        ], {
          className: "w-full px-3 py-2 border rounded mb-2",
          onchange: testChangeEvent
        }),
        span(`Change Events: ${changeCount}`, { className: "text-sm text-gray-600" })
      ], { className: "mb-4" }),
      div([
        form([
          input(null, {
            type: "text",
            placeholder: "Test form submission",
            className: "w-full px-3 py-2 border rounded mb-2"
          }),
          button("Test Submit Event", {
            type: "submit",
            className: "px-4 py-2 bg-green-600 text-white rounded"
          })
        ], {
          onsubmit: testSubmitEvent
        }),
        span(`Submit Events: ${submitCount}`, { className: "text-sm text-gray-600 ml-2" })
      ], { className: "mb-4" }),
      div([
        h3("Event Results:", { className: "font-bold mb-2" }),
        ...Object.entries(eventResults || {}).map(([key, value]) =>
          div(`${key}: ${value}`, {
            className: "p-2 bg-gray-100 rounded mb-1"
          })
        )
      ])
    ], { className: "mb-8 p-4 border rounded" }),
    
    // Forms & Validation Tests
    currentTest === 'forms' && div([
      h2("üìù Forms & Validation Tests", { className: "text-2xl font-bold mb-4" }),
      form([
        div([
          label("Name:", { className: "block mb-1 font-medium" }),
          input(null, {
            type: "text",
            value: formData.name,
            placeholder: "Enter your name",
            className: `w-full px-3 py-2 border rounded ${formErrors.name ? 'border-red-500' : ''}`,
            oninput: (e) => setFormData(prev => ({ ...prev, name: e.target.value }))
          }),
          formErrors.name && p(formErrors.name, { className: "text-red-600 text-sm mt-1" })
        ], { className: "mb-4" }),
        div([
          label("Email:", { className: "block mb-1 font-medium" }),
          input(null, {
            type: "email",
            value: formData.email,
            placeholder: "Enter your email",
            className: `w-full px-3 py-2 border rounded ${formErrors.email ? 'border-red-500' : ''}`,
            oninput: (e) => setFormData(prev => ({ ...prev, email: e.target.value }))
          }),
          formErrors.email && p(formErrors.email, { className: "text-red-600 text-sm mt-1" })
        ], { className: "mb-4" }),
        div([
          label("Message:", { className: "block mb-1 font-medium" }),
          textarea(null, {
            value: formData.message,
            placeholder: "Enter your message",
            className: `w-full px-3 py-2 border rounded h-24 ${formErrors.message ? 'border-red-500' : ''}`,
            oninput: (e) => setFormData(prev => ({ ...prev, message: e.target.value }))
          }),
          formErrors.message && p(formErrors.message, { className: "text-red-600 text-sm mt-1" })
        ], { className: "mb-4" }),
        div([
          button("Submit Form", {
            type: "submit",
            className: "px-4 py-2 bg-blue-600 text-white rounded mr-2"
          }),
          button("Test Validation", {
            type: "button",
            onclick: testFormValidation,
            className: "px-4 py-2 bg-gray-600 text-white rounded"
          })
        ])
      ], {
        onsubmit: testFormSubmission
      }),
      formSubmitted && div([
        p("‚úÖ Form submitted successfully!", {
          className: "text-green-600 font-semibold mt-4"
        }),
        p(`Name: ${formData.name}`, { className: "text-sm text-gray-600" }),
        p(`Email: ${formData.email}`, { className: "text-sm text-gray-600" }),
        p(`Message: ${formData.message}`, { className: "text-sm text-gray-600" })
      ], { className: "mt-4 p-4 bg-green-50 rounded" }),
      div([
        h3("Results:", { className: "font-bold mb-2" }),
        ...Object.entries(formResults || {}).map(([key, value]) =>
          div(`${key}: ${value}`, {
            className: "p-2 bg-gray-100 rounded mb-1"
          })
        )
      ], { className: "mt-4" })
    ], { className: "mb-8 p-4 border rounded" }),
    
    // State Management Tests
    currentTest === 'state' && div([
      h2("üîÑ State Management Tests", { className: "text-2xl font-bold mb-4" }),
      p("Comprehensive tests for useState, state updates, batching, and state persistence", {
        className: "text-gray-600 mb-4"
      }),
      
      div([
        button("Test Basic State Update", {
          onclick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            testStateUpdate();
          },
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        button("Test Object State", {
          onclick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            testStateObject();
          },
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        button("Test Array State", {
          onclick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            testStateArray();
          },
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        button("Test State Batching", {
          onclick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            testStateBatching();
          },
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        button("Test State Persistence", {
          onclick: (e) => {
            e.preventDefault();
            e.stopPropagation();
            testStatePersistence();
          },
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        button("Clear Logs", {
          onclick: () => setStateTestLogs([]),
          className: "px-4 py-2 bg-gray-600 text-white rounded mr-2 mb-2"
        })
      ], { className: "mb-4" }),
      
      div([
        p(`Counter: ${typeof stateTestCounter === 'number' ? stateTestCounter : 0}`, { className: "text-sm text-gray-600" }),
        p(`Object Count: ${stateTestObject?.count || 0}`, { className: "text-sm text-gray-600" }),
        p(`Array Length: ${Array.isArray(stateTestArray) ? stateTestArray.length : 0}`, { className: "text-sm text-gray-600" }),
        p(`Array Values: [${Array.isArray(stateTestArray) ? stateTestArray.join(', ') : 'N/A'}]`, { className: "text-sm text-gray-600" })
      ], { className: "mb-4 p-4 bg-gray-50 rounded" }),
      
      div([
        h3("Results:", { className: "font-bold mb-2" }),
        ...(() => {
          const results = stateTestResults || {};
          const entries = Object.entries(results);
          if (entries.length > 0) {
            return entries.map(([key, value]) =>
              div(`${key}: ${value}`, {
                className: "p-2 bg-gray-100 rounded mb-1"
              })
            );
          } else {
            return [div("No results yet. Click a test button above.", {
              className: "p-2 bg-gray-50 rounded text-gray-500 italic"
            })];
          }
        })()
      ], { className: "mb-4" }),
      
      div([
        h3("üìã Test Logs:", { className: "font-bold mb-2" }),
        div([
          ...(() => {
            const logs = Array.isArray(stateTestLogs) ? stateTestLogs : [];
            if (logs.length === 0) {
              return [div("No logs yet. Run a test to see detailed execution logs.", {
                className: "p-2 bg-gray-50 rounded text-gray-500 italic"
              })];
            }
            return logs.slice(-20).map((log, idx) => {
              const bgColor = log.type === 'error' ? 'bg-red-50 border-red-200' : 
                            log.type === 'success' ? 'bg-green-50 border-green-200' :
                            log.type === 'framework' ? 'bg-blue-50 border-blue-200' :
                            'bg-gray-50 border-gray-200';
              const textColor = log.type === 'error' ? 'text-red-800' : 
                              log.type === 'success' ? 'text-green-800' :
                              log.type === 'framework' ? 'text-blue-800' :
                              'text-gray-800';
              return div([
                span(`[${log.timestamp}]`, { className: "text-xs text-gray-500 mr-2" }),
                span(log.message, { className: textColor })
              ], {
                className: `p-2 border rounded mb-1 text-sm ${bgColor}`
              });
            });
          })()
        ], { className: "max-h-96 overflow-y-auto" })
      ])
    ], { className: "mb-8 p-4 border rounded" }),
    
    // HTML Helpers Tests
    currentTest === 'html' && div([
      h2("üè∑Ô∏è HTML Helpers Tests", { className: "text-2xl font-bold mb-4" }),
      button("Test HTML Helpers", {
        onclick: testHtmlHelpers,
        className: "px-4 py-2 bg-blue-600 text-white rounded mb-4"
      }),
      div([
        h3("HTML Elements Rendered:", { className: "font-bold mb-2" }),
        div([
          h1("H1 Heading", { className: "text-2xl" }),
          h2("H2 Heading", { className: "text-xl" }),
          p("Paragraph text", { className: "text-gray-600" }),
          strong("Bold text"),
          em("Italic text"),
          code("Code text", { className: "bg-gray-100 px-2 py-1 rounded" }),
          ul([
            li("List item 1"),
            li("List item 2"),
            li("List item 3")
          ]),
          table([
            thead([
              tr([
                th("Header 1"),
                th("Header 2")
              ])
            ]),
            tbody([
              tr([
                td("Cell 1"),
                td("Cell 2")
              ])
            ])
          ], { className: "border-collapse border border-gray-300" })
        ], { className: "space-y-2" })
      ], { className: "mb-4" }),
      div([
        h3("Results:", { className: "font-bold mb-2" }),
        ...Object.entries(htmlResults || {}).map(([key, value]) =>
          div(`${key}: ${value}`, {
            className: "p-2 bg-gray-100 rounded mb-1"
          })
        )
      ])
    ], { className: "mb-8 p-4 border rounded" }),
    
    // Navigation Tests
    currentTest === 'navigation' && div([
      h2("üß≠ Navigation Tests", { className: "text-2xl font-bold mb-4" }),
      div([
        button("Test usePath", {
          onclick: testNavigation,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        button("Test navigate", {
          onclick: testNavigate,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2"
        }),
        p(`Current Path: ${usePath()}`, {
          className: "text-sm text-gray-600 mt-2"
        })
      ], { className: "mb-4" }),
      div([
        h3("Results:", { className: "font-bold mb-2" }),
        ...Object.entries(navResults || {}).map(([key, value]) =>
          div(`${key}: ${value}`, {
            className: "p-2 bg-gray-100 rounded mb-1"
          })
        )
      ])
    ], { className: "mb-8 p-4 border rounded" }),
    
    // Authentication Tests
    currentTest === 'auth' && div([
      h2("üîê Authentication Tests", { className: "text-2xl font-bold mb-4" }),
        div([
        button("Test Login", {
          onclick: testLogin,
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        }),
        button("Test Register", {
          onclick: testRegister,
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        }),
        button("Test Get Current User", {
          onclick: testGetCurrentUser,
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        })
      ], { className: "mb-4" }),
            div([
        h3("Results:", { className: "font-bold mb-2" }),
        ...(() => {
          const authResults = Object.entries(testResults || {})
            .filter(([key]) => ['login', 'register', 'getCurrentUser'].includes(key));
          if (authResults.length > 0) {
            return authResults.map(([key, value]) =>
              div(`${key}: ${value}`, {
                className: "p-2 bg-gray-100 rounded mb-1"
              })
            );
          } else {
            return [div("No results yet. Click a test button above.", {
              className: "p-2 bg-gray-50 rounded text-gray-500 italic"
            })];
          }
        })()
      ])
    ], { className: "mb-8 p-4 border rounded" }),
    
    // Database Tests
    currentTest === 'database' && div([
      h2("üíæ Database Tests", { className: "text-2xl font-bold mb-4" }),
        div([
        button("Test Create Record", {
          onclick: testCreateRecord,
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        }),
        button("Test Get Records", {
          onclick: testGetRecords,
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        }),
        button("Test Update Record", {
          onclick: testUpdateRecord,
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        }),
        button("Test Delete Record", {
          onclick: testDeleteRecord,
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        })
      ], { className: "mb-4" }),
      safeRecords.length > 0 ? div([
        h3("Records:", { className: "font-bold mb-2" }),
        ...safeRecords.slice(0, 5).map(record => {
          if (!record || typeof record !== 'object') return null;
          return div([
            strong(record.title || `Record ${record.id || 'Unknown'}`),
            p(record.content || 'No content', { className: "text-sm text-gray-600" })
          ], {
            className: "p-2 bg-gray-100 rounded mb-2"
          });
        }).filter(Boolean)
      ]) : null,
      div([
        h3("Results:", { className: "font-bold mb-2" }),
        ...(() => {
          const dbResults = Object.entries(testResults || {})
            .filter(([key]) => ['createRecord', 'getRecords', 'updateRecord', 'deleteRecord'].includes(key));
          if (dbResults.length > 0) {
            return dbResults.map(([key, value]) =>
              div(`${key}: ${value}`, {
                className: "p-2 bg-gray-100 rounded mb-1"
              })
            );
          } else {
            return [div("No results yet. Click a test button above.", {
              className: "p-2 bg-gray-50 rounded text-gray-500 italic"
            })];
          }
        })()
      ])
    ], { className: "mb-8 p-4 border rounded" }),
    
    // Validation & Sanitization Tests
    currentTest === 'validation' && div([
      h2("‚úÖ Validation & Sanitization Tests", { className: "text-2xl font-bold mb-4" }),
        div([
        button("Test Validation", {
          onclick: testValidation,
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        }),
        button("Test Sanitization", {
          onclick: testSanitization,
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        })
      ], { className: "mb-4" }),
    div([
        h3("Results:", { className: "font-bold mb-2" }),
        ...(() => {
          const valResults = Object.entries(testResults || {})
            .filter(([key]) => ['validation', 'sanitization'].includes(key));
          if (valResults.length > 0) {
            return valResults.map(([key, value]) =>
              div(`${key}: ${value}`, {
                className: "p-2 bg-gray-100 rounded mb-1"
              })
            );
          } else {
            return [div("No results yet. Click a test button above.", {
              className: "p-2 bg-gray-50 rounded text-gray-500 italic"
            })];
          }
        })()
      ])
    ], { className: "mb-8 p-4 border rounded" }),
    
    // Error Handling Tests
    currentTest === 'errors' && div([
      h2("‚ö†Ô∏è Error Handling Tests", { className: "text-2xl font-bold mb-4" }),
    div([
        button("Test Validation Error", {
          onclick: () => testErrorHandling('validation'),
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        }),
        button("Test Database Error", {
          onclick: () => testErrorHandling('database'),
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        }),
        button("Test Permission Error", {
          onclick: () => testErrorHandling('permission'),
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        }),
        button("Test Not Found Error", {
          onclick: () => testErrorHandling('notfound'),
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        })
      ], { className: "mb-4" }),
            div([
        h3("Results:", { className: "font-bold mb-2" }),
        ...(() => {
          const errorResults = Object.entries(testResults || {})
            .filter(([key]) => key.startsWith('error_'));
          if (errorResults.length > 0) {
            return errorResults.map(([key, value]) =>
              div(`${key}: ${value}`, {
                className: "p-2 bg-gray-100 rounded mb-1"
              })
            );
          } else {
            return [div("No results yet. Click a test button above.", {
              className: "p-2 bg-gray-50 rounded text-gray-500 italic"
            })];
          }
        })()
      ])
    ], { className: "mb-8 p-4 border rounded" }),
    
    // Performance Tests
    currentTest === 'performance' && div([
      h2("‚ö° Performance Tests", { className: "text-2xl font-bold mb-4" }),
    div([
        button("Test Performance (1000 iterations)", {
          onclick: testPerformance,
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        })
      ], { className: "mb-4" }),
        div([
        h3("Results:", { className: "font-bold mb-2" }),
        ...((testResults && testResults.performance)
          ? [div(`performance: ${testResults.performance}`, {
              className: "p-2 bg-gray-100 rounded mb-1"
            })]
          : [div("No results yet. Click a test button above.", {
              className: "p-2 bg-gray-50 rounded text-gray-500 italic"
            })])
      ])
    ], { className: "mb-8 p-4 border rounded" }),
    
    // Security Tests
    currentTest === 'security' && div([
      h2("üõ°Ô∏è Security Tests", { className: "text-2xl font-bold mb-4" }),
      p("Run targeted security checks for XSS sanitization and SQL injection prevention using parameterized queries.", {
        className: "text-gray-600 mb-4"
      }),
      div([
        button("Test XSS Prevention", {
          onclick: testSanitization,
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        }),
        button("Test SQL Injection Prevention", {
          onclick: testSqlInjectionPrevention,
          disabled: loading,
          className: "px-4 py-2 bg-blue-600 text-white rounded mr-2 mb-2 disabled:opacity-50"
        })
      ], { className: "mb-4" }),
      div([
        h3("Results:", { className: "font-bold mb-2" }),
        ...(() => {
          const securityResults = Object.entries(testResults || {})
            .filter(([key]) => ['sanitization', 'sqlInjection'].includes(key));
          if (securityResults.length > 0) {
            return securityResults.map(([key, value]) =>
              div(`${key}: ${value}`, {
                className: "p-2 bg-gray-100 rounded mb-1"
              })
            );
          }
          return [div("No security test results yet. Run a test above.", {
            className: "p-2 bg-gray-50 rounded text-gray-500 italic"
          })];
        })()
      ])
    ], { className: "mb-8 p-4 border rounded" }),
    
    // Loading Indicator
    loading && div([
      p("Loading...", {
        className: "text-blue-600 font-semibold"
      })
    ], { className: "text-center py-4" }),
    
    // Test Summary
    Object.keys(testResults || {}).length > 0 && div([
      h2("üìä Test Summary", { className: "text-2xl font-bold mb-4" }),
            div([
        p(`Total Tests: ${Object.keys(testResults || {}).length}`, {
          className: "font-semibold"
        }),
        p(`Passed: ${Object.values(testResults || {}).filter(r => r && typeof r === 'string' && r.includes('‚úÖ')).length}`, {
          className: "text-green-600 font-semibold"
        }),
        p(`Failed: ${Object.values(testResults || {}).filter(r => r && typeof r === 'string' && r.includes('‚ùå')).length}`, {
          className: "text-red-600 font-semibold"
        })
      ], { className: "p-4 bg-gray-100 rounded" })
    ], { className: "mt-8" })
  ], {
    className: "max-w-6xl mx-auto p-8"
  });
}
